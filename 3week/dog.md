1.  obj1 === obj2 false인 이유는?

```
const obj1 = { number1: '10'};
const obj2 = { number2: '11'};
```

설명

원시형, 참조 형 데이터는 주소를 참조한다는 공식은 똑같습니다.
원시형 데이터는 원시 값의 메모리 주소를 참조합니다.
한번 생성된 원시형 데이터는 GC대상이 되지 않는 한 메모리에서 사라지지 않습니다.

| 식별자  | 데이터영역 | @5001 |
| ------- | ---------- | ----- |
| number2 | @5001      | 10    |
| number1 | @5002      | 11    |

이런식으로 원시 값을 가리키는 식별자는 값으로 원시 값의 주소를 참조하게 되는겁니다.
10을 두 식별자가 참조하고 있다면 두 식별자가 가리키는 메모리 주소는 원시 값 10의 주소
@5001이 됩니다.

잠깐 객체를 살펴보겠습니다.
객체의 경우

| 식별자 | 데이터영역 |
| ------ | ---------- |
| obj1   | @8002      |
| obj2   | @8003      |

보다싶이 객체들은 하나의 값만 담는게 아닌 여러개의 데이터를 만들어내야하기 떄문에
변수영역,데이터영역이 나눠져있습니다. 변수영역이란 프로퍼티를 그룹핑한것을 뜻합니다.

| 메모리주소 | 데이터영역 |
| ---------- | ---------- |
| @8002      | @7001~?    |

일단 여기서 원시형 데이터를 갖고 있는 변수와 객체를 비교해봤을때 공통점이 있습니다.
바로 식별자가 어떤 메모리 주소를 가리킵니다.
서로 가리키는 데이터 영역이 다릅니다.
서로 가리키는 데이터영역이 다르면 false를 나타냅니다.

```
const obj1 = {name : '킹콩'};
const obj2 = obj1;
```

obj1 = obj2로 할당하게 된다면 객체들은 그룹핑한 메모리 주소를 갖고 있기 때문에
식별자 obj1, obj2 의 메모리주소는 같아지게 됩니다.
|식별자|데이터영역|
|---|---|
|obj1|@8002|
|obj2|@8002|

콘솔을 찍어보면 obj1 === obj2 true를 반환합니다.
이제 가리키는 메모리주소가 같다면 true를 반환한다는 공식이 생겼네요

객체의 변수영역을 들여다보겠습니다.

| 식별자 | 데이터영역 |
| ------ | ---------- |
| obj1   | @8002      |
| obj2   | @8002      |

| 변수영역 | 데이터영역                |
| -------- | ------------------------- |
| @8002    | @7001~?                   |
| @7001    | 이름: number/value: @5001 |

그룹핑한 변수영역에는 프로퍼티 키들이 원시 값의 주소를 값으로 가지고 있습니다.

| 메모리주소 | 데이터영역 |
| ---------- | ---------- |
| @5001      | 10         |

앞전에 설명드렸다싶이
한번 생성된 원시형 데이터는 GC대상이 되지 않는 한 메모리에서 사라지지 않습니다.
@5001 메모리 주소를 참조하고있네요.

```
obj1.name === obj2.name //
```

위 코드의 결과는 true 가 출력됩니다.
서로 가리키는 메모리주소가 같은 두 객체의 값을 비교했습니다.
그래서일까요?

정확히 obj1.name 과 obj2.name이 가리키는 메모리주소는 원시형 데이터를 담은 변수처럼
식별자가 가리키는 메모리주소가 원시 값 자체이기 때문입니다.
원시형 데이터를 참조하고있는 식별자를 비교할 경우 참조형 데이터타입을 참조하는
식별자의 비교는 다릅니다.

그 차이는 식별자가 원시 데이터의 메모리 주소를 가리키느냐,
참조 타입처럼 식별자가 '그룹핑'한 데이터의 메모리 주소를 가리키느냐, 의 차이가 되겠네요

참조, 원시는 메모리를 참조하는 방식은 결국 같은겁니다.
하지만 원시는 가리키는 메모리주소가 '원시 값' 자체가 되고
참조는 가리키는 메모리주소가 원시 값이 아닌 그룹핑한 주소를 가리키는것이죠

여기까지 이해되셨다면 원시형 데이터타입을 좀 더 알아보겠습니다.
원시형 데이터타입에 값을 넣으면 즉, 재할당을 하면 일어나는 메모리의 변화를 살펴보자면

| 식별자  | 데이터영역 | @5001 |
| ------- | ---------- | ----- |
| number2 | @5001      | 10    |
| number1 | @5002      | 11    |

만약 number2 += '일' 을 한다면
|식별자|데이터영역|@5001|
|---|---|---|
|number2|@5001|10일
이렇게 변경되지 않습니다. 새로운 메모리주소에 10 + '일'한 값을 넣습니다.
그리고 그 주소를 참조하게되죠
|식별자|데이터영역|@5007|
|---|---|---|
|number2|@5001|10일
여기까지 이해되셨다면 다음 문제입니다.

```
let 숫자 = 100;
let 오브젝트 = { name : '홍길동'};
const add = (숫자,오브젝트) => {
    숫자 += 100;
    오브젝트.name = '막국수'
}
add(숫자,오브젝트);
console.log(숫자) //100;
console.log(오브젝트.name) // 막국수

```

어라 이상합니다 숫자라는 변수가 가리키는 메모리주소가 바뀌어서 새로운 주소 값을
참조하면서 함수에서 빠져나와 200이 출력되어야할 것 같은데 예상이 빗나갑니다.

참조 타입은 값이 바뀌어서 나왔습니다. 무슨 일 일까요?

우리가 공부했듯이 매개변수는 함수 내부에서 매개변수는 지역변수와 동일하게 취급됩니다.
여기서 중요한건 전달과정에있습니다.

매개변수에 값을 전달하는 방식은 모딥다 책에서 배운 것처럼
값에 의한 전달,참조에 의한 전달과 동일합니다.

다시 위 내용으로 돌아가보자면 참조타입인 객체,배열 들은
복수 형태로 들어오는 프로퍼티 키, 값들을 그룹핑해놓습니다.

위 설명에서 Obj1이 참조하고 있던 메모리 주소는 값 자체를 참조하는
원시형 데이터를 가진 변수와는 달랐죠?

참조하는 방식에서 차이가 있듯 이런 실행결과에서도 차이가 나타나게 됩니다.

결국 복사에 의한 전달은 원시, 참조형 타입은 똑같습니다.
다만, 그 메모리 주소가 어디를 가리키느냐에 따라 달라진다고 말씀드렸죠

전역 스코프에 선언된 숫자 변수는 함수의 인자로 들어갈 때
값에 의한 복사가 일어납니다
값에 의한 복사란 가리키는 주소가 값 자체를 뜻하게 되겠죠.

제 생각에는 참조도 뭐 별반 다를거 없어보입니다.
위 식별자 obj가 가리키는 값 자체가 그룹핑한 변수영역이기 때문에
결국 도찐개찐이라는거죠

값 자체를 들고간 변수 숫자는 함수 안으로 들어갑니다.
변수가 생성될때 새로운 메모리 공간에 할당이 되었죠?
식별자가 가리키는 원시 데이터의 메모리 주소는 같으나
식별자 자체가 다른 메모리 영역에 선언되어있기 때문에
전역 스코프의 숫자와 인자 값으로 들어간 숫자는 서로 다른 변수가 됩니다.

값을 누적시켜도 함수 내부에서만 사용할 수 있는 지역변수로 취급되기 떄문이죠
이 값을 쓰려면 '반환문' return하면 될겁니다. 하지만 새로운 변수인건 다름없습니다.
결국 다시 그 값을 가리키는 새로운 식별자를 변수로 만들어 전달해야겠죠.

이번엔 오브젝트입니다.
그룹핑한 메모리 주소를 들고갔기 떄문에
어떤 식별자든 가리키는 메모리 주소가 그룹핑한 주소가 됩니다.
이는 식별자가 가리키는 메모리주소가 같기 때문에
어떤 식별자가 온다 하더라도 메모리주소를 참조하지 않는 한 (GC대상)
어떤 식별자든 전부 공유하게 된다는 얘기입니다.

공유된 메모리 주소는 함수에서 나오면 원본 객체가 변형된 상태로 나오게 됩니다.
그럼 obj.name === obj.name이 왜 true를 반환하는지 감이 오시나요?

obj.name은 식별자인 name이 원시 값의 주소 자체를 가리키기 때문에
값끼리 비교가 되는것이죠.

원시형 데이터들은 '불변성'을 지킵니다.
근데 객체, 참조타입들은 '불변성'을 지키기 어렵네요 어떤 방법이 있을까요

값이 달라진다면 추적하기도 어려울뿐더러 어떤 부수 효과가 나타난다면
오류를 피하기도 힘들고, 고치기도 힘듭니다.

마지막 문제입니다.

이전까지의 문제를 이해하셨다면 순수함수를 의미하는게 무엇인지 알 수 있습니다.
원래의 객체나 값을 변경시키지 않는 불변성을 지키는 순수함수를 만들어주세요.

```
  const a = {name: '열무김치'};

var add = (f,a,b) => {
   var res =  {...f(a), name: b};
   return res;
};

add((a)=> a, a, '김치국');

```
