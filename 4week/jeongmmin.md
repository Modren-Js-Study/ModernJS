## 1. 아래 코드를 실행 시 console.log의 결과값은 각각 무엇일까요?

```jsx
// --------------------------- 1-1번 ---------------------------

var x = 10;
function foo() {
var x = 20;
if (true) {
var x = 30;
}
console.log(x);
}


foo();
console.log(x);

// --------------------------- 1-2번 ---------------------------

let y = 10;
function bar() {
  let y = 20;
  if (true) {
    let y = 30;
  }
  console.log(y);
}
bar();
console.log(y);


// --------------------------- 1-3번 ---------------------------
const z = 10;
function baz() {
  const z = 20;
  if (true) {
    const z = 30;
  }
  console.log(z);
}
baz();
console.log(z);
```
<br/>
<br/>

<details>
<summary>풀이 답안</summary>

- **1번 ⇒ 30, 10**

  'var'는 함수 레벨 스코프를 가지기 때문에 'foo' 함수 내에서 'var x = 20;'과 'var x = 30;'은 같은 변수 'x'를 참조합니다. 따라서 'foo' 함수 내에서 'console.log(x);'는 '30'을 출력합니다.

  그리고 'var x = 10;'은 'foo' 함수 바깥에 선언된 전역 변수 'x'를 참조하므로, 'foo' 함수 바깥에서 'console.log(x);'는 '10'을 출력합니다.

- **2번 ⇒ 20, 10**

  'let'은 블록 레벨 스코프를 가지므로, 'bar' 함수 내에서 'let y = 20;'과 'if' 블록 내의 'let y = 30;'은 서로 다른 변수 'y'를 참조합니다. 따라서 'bar' 함수 내에서 'console.log(y);'는 '20'을 출력합니다.

  그리고 'let y = 10;'은 'bar' 함수 바깥에 선언된 전역 변수 'y'를 참조하므로, 'bar' 함수 바깥에서 'console.log(y);'는 '10'을 출력합니다.

- **3번 ⇒ 20, 10**

  'baz' 함수 내에서 'console.log(z);'는 '20'을 출력하고, 'baz' 함수 바깥에서 'console.log(z);'는 '10'을 출력합니다.
</details>

<br/>
<br/>
<br/>

## 2. 동적스코프(Dynamic scope)와 렉시컬 스코프(lexical scope)란 무엇인가요? 
### <br/> (자바스크립트에서는 어떤것을 사용하는지도 알려주세요.)

<br/>
<br/>

<details>
<summary>풀이 답안</summary>

먼저 스코프의 정의는 다음과 같습니다.

```
 선언된 변수에 대해서 접근할 수 있는 유효한 범위를 의미
```

  | 동적 스코프 | 정적 스코프 |
  | --- | --- |
  | 함수를 **어디서 호출했는지에 따라** 함수의 상위 스코프를 결정한다 | 함수를 **어디서 정의했는지에 따라** 함수의 상위 스코프를 결정한다. |
  | - | 자바스크립트및 여러 언어에서 사용함 |
  | 프로그램 런타임 도중에 실행 콘텍스트나 호출 콘텍스트에서 결정 | 소스코드가 작성된 콘텍스트에서 결정 |

<br/>

- 자바스크립트는 렉시컬 스코프를 가진 언어로, 함수를 어디서 호출하는지가 아닌 어디에 선언하였는지에 따라 상위 스코프가 결정됩니다.

- 예를 들어, 함수 **내부**에서 선언한 변수는 **그 함수 내부에서만 접근**할 수 있고, 함수 외부에서는 접근할 수 없습니다. <br/>
반대로, 함수 **외부**에서 선언한 변수는 **그 변수를 선언한 스코프 내부뿐만 아니라 그 스코프에 중첩된 내부 함수에서도 접근**할 수 있습니다.

- 이렇게 렉시컬 스코프는 코드를 보다 예측 가능하게 만들어줍니다. 
왜냐하면 변수를 참조할 때 그 위치를 알기 위해서는 그 변수가 선언된 위치만을 확인하면 되기 때문입니다.
</details>