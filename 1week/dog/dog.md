1996년 8월, 마이크로소프트는 자바스크립트의 파생 버전인 JSscript를 인터넷 익스프롤러 3.0에 탑재했다. 문제는 js와 jsscript가 표준화되지 못하고 적당히 호환되었다는 것이다.

즉 넷스케이프 커뮤니케이션즈와 마이크로스프트는 자사 브라우저의 시장 점유율을 높이기위해 자사 브라우저에서만 동작하는 기능을 경쟁적으로 추가하기 시작했다는 것이다.

브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 크로스 브라우징 이슈가 발생하기 시작했고 결과적으로 모든 브라우저에서 정상적으로 동작하는 웹페이지를 개발하기가 무척 어려워졌다.

이에 자바스크립트의 파편화를 방지하고 모든 브라우저에서 정상적으로 동작하는 표준화된 자바스크립트의 필요성이 대두되기 시작했다.

모든 브라우저에서 정상적으로 동작하는 표준화된 자바스크립트의 필요성이 대두되기 시작했다 → **우리가 앞으로 쓰게될 그리고 썻었던 프레임워크들이 이러한 어떤 부가적인 요소로인해 통일성이 필요하다고 느꼈을 때 프레임워크가 탄생한게 아닐까..?**

구글 맵스를 통해 웹 애플리케이션 프로그래밍 언어로서의 가능성이 확인된 자바스크립트로 웹 애플리케이션을 구축하려는 시도가 늘면서 더욱 빠르게 동작하는 자바스크립트 엔진의 필요성이 대두되었습니다.

1년 뒤 라이언달이 발표한 Node.js는 구글 v8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경입니다. // → **런타임 환경이란?**

Node.js는 브라우저의 자바스크립트 엔진에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서도 동작할 수 있도록 자바스크립트 엔진을 브라우저에서 독립시킨 자바스크립트 실행 환경입니다.

Node.js는 자바스크립트 엔진을 기반으로 하므로 Node.js 환경에서 동작하는 애플리케이션은 자바스크립트를 사용해 개발합니다. 프론트엔드와 백엔드 영역에서 자바스크립트를 사용할 수 있다는 동형성은 별도의 언어를 학습하기 위한 시간을 덜 수 있다는 장점이 있습니다.

Node.js는 비동기 I/O를 지원하며 단일 스레드 이벤트 루프 기반으로 동작함으로 써 요청 처리 성능이 좋습니다.

Node.js는 데이터를 실시간으로 처리하기 위해 I/O가 번번하게 발생하는

Single Page Application에 적합하다.

하지만 CPU 사용률이 높은 애플리케이션에는 권장하지 않는다.

**자바스크립트의 특징**

자바스크립트는 HTML,CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어다. 다른 프로그래밍 언어와 마찬가지로 다른 프로그래밍 언어에서 많은 영향을 받았는데 기본 문법은 C,자바와 유사하고 self에서는 프로토타입 기반 상속을, 스킴에서는 일급 함수의 개념을 차용했다.

일급함수라는 개념으로 oop,함수형 프로그래밍을 지원하지만

결국 자바스크립트를 구성하는 ‘거의 모든 것’이 객체입니다.

원시 값을 제외한 나머지 값 (함수,배열,정규 표현식 등)

자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어다. 대부분의 모던 자바스크립트 엔진은 인터프리터와 컴파일러의 장점을 결합해 비교적 처리 속도가 느린 인터프리터의 단점을 해결했다.

인터프리터는 소스코드를 즉시 실행하고 컴파일러는 빠르게 동작하는 머신 코드를 생성하고 최적화한다. 이를 통해 컴파일 단계에서 추가적인 시간이 필요함에도 더욱 빠르게 코드를 실행할 수 있다.

<aside>
❗ 하지만 대부분의 모던 브라우저에서 사용되는 인터프리터는 전통적인 컴파일 언어 처럼 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 거치며 일부 소스코드를 컴파일하고 실행한다.

이를 통해 인터프리터 언어의 장점인 동적 기능 지원을 살리면서 실행 속도가 느리다는 단점을 극복한다. 따라서 현재는 컴파일러와 인터프리터의 기술적 구분이 점차 모호해져 가는 추세다. 하지만 자바스크립트는 런타임에 컴파일되며 실행 파일이 생성되지 않고 인터프리터의 도움 없이 실행할 수 없기 때문에 컴파일러 언어라고 할 수는 없다.

</aside>

컴파일되는 언어는 프로그래밍 언어로 코드를 짜고 나서 그걸 실행하기 전에 ‘미리’, 컴퓨터가 읽을 수 있는 언어로 번역 작업을 해두는 걸 말합니다.

컴퓨터가 자국어로 된 코드를 읽기 떄문에 실행속도도 빠릅니다.

이건 우리가 유튜브 클론코딩할때를 예시로 퍼그가 HTML파일로 변환돼서 보여지죠? 그걸 예로 들 수 있을 것 같습니다.

인터프리터언어는 실시간으로 컴퓨터에게 코드를 읽어줘서 일을 시키는 걸 뜻한다.

개발이 더 간편하지만 오류에 더 취약하고 실행이 더 느립니다.

자바스크립트는 한 줄씩 실행된다고 하죠? 작은 규모에선 빨라도 큰 프로젝트에서는 실행이 느려지겠죠.

실제로 자바를 실행할때 우리가 흔히 디버깅하는 용도로 쓰이는 console.log처럼 바로 실행되지 않고 컴파일이 된 후 실행됩니다 이건 두눈으로도 확인할 수 있습니다!

큰 규모에서는 컴파일언어가 안정적이고 미리 컴파일하여 실행하기 떄문입니다!

하지만 최근에는 인터프리터 언어의 성능이 향상되어 보다 큰 프로젝트에서도 사용되고 있다고합니다!

**변수란 무엇인가? 왜 필요한가?**

변수는 메모리주소를 가르키는 메모리주소에 저장된 값에 대한 식별자입니다.

각 셀은 고유의 메모리 주소를 갖습니다. 이 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현된다.

10+20을 해도 연산결과가 그대로 출력됩니다

변수에 담지않은 결과값을 재사용하려면 메모리 주소를 통해 연산 결과 30이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없습니다.

하지만 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않습니다.

결국 변수는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공합니다.

값의 위치를 가리키는 상징적인 이름입니다.

변수는 하나의 값을 저장하기 위한 메커니즘입니다. 여러 개의 값을 저장하려면 여러 개의 변수를 사용해야 합니다. 단, 배열이나 객체 같은 자료구조를 사용하면 관련이 있는 여러 개의 값을 그룹화해서 하나의 값처럼 사용할 수 있습니다.

메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수 이름이라 한다.

그리고 변수에 저장된 값을 변수 값이라고합니다.

변수에 값을 저장하는 것을 **할당(대입,저장)이라하고, 변수에 저장된 값을 읽어 들이는 것을 참조라 합니다.**

**변수선언**

변수이름을 식별자라고도 합니다. **식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말합니다.** 사람을 이름으로 구별해서 식별하는 것처럼 값도 식별자로 구별해서 식별할 수 있습니다.

값은 메모리 공간에 저장되어 있습니다. 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해 낼 수 있어야합니다. 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억해야합니다.

식별자라는 용어는 변수 이름에만 국한해서 사용하지 않습니다. 예를 들어 변수, 함수, 클래스등의 이름은 모두 식별자입니다.

변수 선언이란 변수를 생성하는 것을 말합니다. 좀 더 자세히 말하면 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결(binding)해서 값을 저장할 수 있게 준비하는 것이다. 변수 선언에 의해 확보된 메모리 공간은 확보가 해제 되기전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할수 있다.

**변수를 사용하려면 반드시 선언이 필요합니다. 변수를 선언할 때는 var,let,const 키워드를 사용합니다.**

let,const 키워드가 도입되기 이전까지 var 키워드는 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드였습니다.

<aside>
❗ var 키워드의 여러 단점 중에서 가장 대표적인 것이 블록 레벨 스코프를 지원하지않고 함수 레벨 스코프를 지원하는것입니다. 이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생하기도 합니다. 밑에 코드 참고

</aside>

```jsx
if (true) {
    var x = 10;
    console.log(x); // 10
}
console.log(x); //10
```

간단하게 함수레벨 스코프란 언뜻보면 함수안에서만 존재하는 스코프라고 생각하실수도 있는데

함수를 제외한 모든 스코프가 공유된다는 말입니다 의도치않게 전역변수로 선언하게됩니다.

변수 선언 후 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 어플리케이션이 사용했던 값이 남아있을 수 있다. 이러한 값을 garbage value라 한다.

자바스크립트의 var 키워드는 암묵적으로 초기화를 수행하므로 이러한 위험으로부터 안전합니다

선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생합니다.

**변수 선언의 실행 시점과 변수 호이스팅**

호이스팅이란 : **선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 한다**

큰 프로젝트에서 컴파일언어가 가지는 안정성이란 무엇일까..

**일단 자바스크립트에서 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 런타임이 아니라 그 이전단계에서 먼저 실행이됩니다.**

자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 합니다. 이때 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행합니다. 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한줄씩 실행시킵니다.

**값의 할당**

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행됩니다.

**문,식은 런타임이전에 평가되고 할당은 런타임 이후**

**식별자 네이밍 규칙**

예약어는 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말합니다.

예약어는 변수로 선언할 수 없습니다. 식별자라면 모두 다요

ex var,const,let,function,new …

```jsx
// 카멜케이스
var firstName;
// 스네이크 케이스
var first_name;
// 파스칼 케이스
var FirstName;
// 헝가리언 케이스
var strFirstName; // type + identifier
var $elem = document.getElementById("myId");
```

웹 기초 스터디 하면서 저희가 자주쓴 카멜케이스입니다.

제가 알기로는 요즘 개발자분들은 카멜케이스를 쓰고

좀 옛날 개발자.. 서브언어가 자바스크립트이신 분들이 스네이크,파스칼,헝가리언 등 자주 쓰십니다. 실제로 개발자 지인분이 소스코드 잠깐 보여주셨는데 레거시 코드들이 대부분 카멜케이스를 제외한 전부였습니다. →**지인분은 백앤드 개발자셨음, 프론트앤드는 바벨같은 트랜스파일러로 최신문법으로 작성 한다고함.**

**표현식과 문**

**값**: **값은 식(표현식)이 평가 되어 생성된 결과를 말합니다.**

```jsx
const log = console.log;
var sum = 10 + 20; // log(sum) -> 30
```

변수에 할당되는 것은 10+20의 표현식이 아니라 10+20이 평가된 결과인 숫자 값 30이다.

**리터럴: 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말합니다.**

리터럴은 사람이 이해할 수 있는 문자(아라비아, 숫자, 알파벳) 또는 미리 약속된 기호 (””, “”, .,[],{},//등)로 표기한 코드입니다. 자바스크립트 엔진은 코드가 실행되는 시점인 **런타임에** 리터럴을 평가해 값을 생성합니다.

**표현식: 표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조합니다.**

앞서 살펴번 리터럴은 값으로 평가됩니다. 따라서 리터럴도 표현식입니다.

**문: 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위입니다.**

문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍입니다.

문은 여러 토큰으로 구성됩니다. **토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미합니다.** 예를 들어, 키워드,식별자,연산자,리터럴,세미콜론(;)이나 마침표(.)등의 특수 기호는 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소이므로 모두 토큰입니다.

**문을 명령문이라고도 부릅니다. 즉, 문은 컴퓨터에게 내리는 명령입니다.**

문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있습니다.

세미콜론은 문의 종료를 나타냅니다. 자바로 예를 들자면 자바스크립트 개발자는 실수로 세미콜론을 붙이지 않아도 실행시킬 수 있습니다. 하지만 자바같은 정적언어는 규칙이 까다롭습니다.

세미콜론을 붙이지 않으면 바로 빨간줄이 그어집니다. 실행도 안됩니다. 자바스크립트에서는 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입기능이 암묵적으로 수행됩니다.

(자유분방언어와 정적언어를 비교하니 조금씩 체감되지 않나요? 안정성이라는게? )

**문/ 표현식을 구별해보자**

문에는 표현식인 문과 표현식이 아닌 문이 있습니다. 표현식인 문은 값으로 평가될 수 있는 문이며,

표현식이 아닌 문은 값으로 평가될 수 없는 문을 말합니다.

변수 선언문은 값으로 평가 x

따라서 변수 선언문은 표현식이 아닌 문입니다.

하지만 할당문은 값으로 평가될 수 있습니다. 따라서 표현식이 아닌 문입니다

값의 유무에따라 표현식과, 선언문으로 나눠집니다.

할당문은 그 자체가 표현식이지만 완전한 문이기도 합니다. 할당문은 표현식인 문입니다.

그래서 이런 코드도 가능합니다

```jsx
var foo = x = 100;
log(foo); -> 100
log(x); -> 100
```

**데이터타입**

자바스크립트의 모든 값은 데이터 타입을 갖습니다. 자바스크립트는 7개의 데이터 타입을 제공합니다. 7개의 데이터 타입은 원시타입과 객체타입으로 분류할 수 있습니다.

**숫자타입**

C나 자바의 경우, 정수와 실수를 구분해서 int,long,float,double등과 같은 다양한 숫자 타입을 제공합니다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재합니다.

자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리한다고 했습니다. 이는 정수로 표현된다 해도 사실은 실수라는 것을 의미합니다.

**문자열 타입**

문자열은 작은 따옴표(’ ’), 큰 따옴표(” ”), 또는 백틱(``)으로 텍스트를 감쌉니다.

타른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰을 구분하기 위해서 입니다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식합니다.

C는 문자열 타입을 제공하지 않고 문자의 배열로 문자열을 표현하고, 자바는 문자열을 객체로 표현합니다. 그러나 자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값입니다.

이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는걸 의미합니다.

**템플릿 리터럴**

템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공합니다. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리됩니다.

**불리언 타입**

불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐입니다.

**undefined타입**

undefined 타입의 값은 undefined가 유일합니다.

var 키워드로 선언한 변수는 암묵적으로 Undefined로 초기화 됩니다.

변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태(garbage value)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화합니다. 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환됩니다.

이처럼 undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값입니다**. 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된적이 없는, 즉 초기화 되지 않은 변수라는 것을 간파할 수 있습니다.**

---

**null**

프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용합니다.

**Symbol**

심벌은 ES6에서 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다.

심벌 값은 다른 값과 중복되지 않은 유일무이한 값이다.

따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

**데이터 타입의 필요성**

값은 메모리에 저장하고 참조할 수 있어야 합니다. 메모리에 값을 저장하려면 먼저 확보해야할 메모리 공간의 크기를 정해야합니다. 다시 말해, 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지를 알아야합니다.

**동적 타이핑**

자바스크립트의 모든 값은 데이터 타입을 갖습니다.

그렇다면 변수는 데이터 타입을 가질까요?

C나 자바 같은 **정적타입 언어는** 변수를 선언할 때 변수에 할당할 수 있는 값의 종류,

즉 데이터 타입을 사전에 선언해야합니다.

이를 명시적 타입 선언이라고 합니다.

정적 타입 언어는 변수의 타입을 변경할 수 없으며 변수에 선언한 타입에 맞는 값만 할당할 수 있습니다. 정적 타입 언어에서는 타입체크를 수행하는데 변수에 담기는 값은 유동적으로 바뀌어서 까다롭지만 디버깅이 엄청 용이합니다. 만약 타입 체크를 통과하지 못했다면 에러를 발생시키고 프로그램 실행 자체를 막습니다.

이를 통해 타입의 일관성을 강제함으로써 더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄입니다.

반면에 자바스크립트같은 **동적언어는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않습니다.** 어떤 데이터 타입이라도 유연하게 할당할 수 있습니다

이건 개발을 막 시작한 초보자들한텐 진입장벽이 쉬워서 부담이 적으나

공부를 조금만 해봐도 정적언어의 데이터타입에대해 조금이라도 알고있다면 향수를 불러올 수 있습니다.

조금 귀찮더라도 오류가 어디서 나는지 확인할 수 있다는것은 정말..축복입니다..

물론 저희가 자바스크립트를 공부하면서 왜 정적언어랑 자꾸 비교하냐 물으신다면

충분히 그런생각 하실 수 있지만 제 생각엔 개발하는 사람들이란 어떤 문제가 일어나면

어떻게 해결해야 좋은 결과가 나올 수 있을까를 계속 고민하는 사람들입니다.

프로그래밍 세계에서 무언가를 학습하려고 할 때에는 그 이론 자체를 이해하기 보다는 먼저 그 기술이 나오게 된 배경을 이해하는 것이 굉장히 중요하다고 생각합니다. 그래야 새로운 반환점을 맞이했을 때 맥락에 맞게 내 것으로 만드는게 쉬워지기 때문입니다.

자바스크립트에서 데이터타입을 확인하려면 typeof 연산자가 있습니다.

typeof 연산자가 엄청 정확하진 않습니다. 뭐 거의 정확하긴합니다만

```jsx
typeof null === "object"; // true;
```

typeof연산자의 버그인데 다른 자바스크립트책에선 20년동안 끈덕지게 버텨온 버그라고합니다.

```jsx
null 의 타입을 정확하게 확인하려면 조건이 하나 더 추가되면 됩니다
var a = null;
(!a && typeof a === "object") // true;
// null은 falsy한 유일한 원시값이지만 타입은 'object'인 특별한 존재
```

typeof 연산자로 변수를 연산하면 변수의 데이터 타입을 반환합니다. 정확히 말하면 변수의 데이터 타입을 반환하는 것이 아니라 변수에 할당된 값의 데이터 타입을 반환합니다.

자바스크립트의 변수는 선언이 아닌 할당에 의한 타입이 결정( 타입 추론 )됩니다. 그리고

재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있습니다.

이러한 특징을 동적 타이핑이라 하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입 언어라고 합니다.

결국 여태까지 설명드린것처럼 동적 타입 언어의 유연성은

진입 장벽을 낮춰주지만 신뢰성은 떨어집니다.
